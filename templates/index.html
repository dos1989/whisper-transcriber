<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å»£æ±è©±èªéŸ³è½‰æ–‡å­—</title>
    <link rel="stylesheet" href="/static/style.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>ğŸ™ï¸ å»£æ±è©±èªéŸ³è½‰æ–‡å­—</h1>
            <p class="subtitle">ä¸Šå‚³ MP3 éŒ„éŸ³ï¼Œå³æ™‚è½‰æ›æˆæ–‡å­—</p>
        </header>

        <main>
            <!-- æ¨¡å¼åˆ‡æ› -->
            <div class="mode-toggle">
                <button class="mode-btn active" id="singleModeBtn" data-mode="single">
                    <span class="mode-icon">ğŸ“„</span>
                    å–®æª”æ¨¡å¼
                </button>
                <button class="mode-btn" id="batchModeBtn" data-mode="batch">
                    <span class="mode-icon">ğŸ“</span>
                    æ‰¹é‡æ¨¡å¼
                </button>
            </div>

            <!-- ä¸Šå‚³å€åŸŸ -->
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">ğŸ“</div>
                <p class="upload-text" id="uploadText">æ‹–æ‹½éŸ³æª”åˆ°é€™è£¡ï¼Œæˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
                <p class="upload-hint">æ”¯æ´æ ¼å¼ï¼šMP3, WAV, M4A, OGG, FLACï¼ˆæœ€å¤š 10 å€‹æª”æ¡ˆï¼‰</p>
                <input type="file" id="fileInput" accept=".mp3,.wav,.mp4,.m4a,.ogg,.flac,.webm" hidden>
            </div>

            <!-- å–®æª”è³‡è¨Š -->
            <div class="file-info" id="fileInfo" style="display: none;">
                <span class="file-name" id="fileName"></span>
                <button class="btn-clear" id="clearBtn">âœ•</button>
            </div>

            <!-- æ‰¹é‡æª”æ¡ˆéšŠåˆ— -->
            <div class="file-queue" id="fileQueue" style="display: none;">
                <div class="queue-header">
                    <h3>ğŸ“‹ æª”æ¡ˆéšŠåˆ— <span id="queueCount">(0 å€‹æª”æ¡ˆ)</span></h3>
                    <button class="btn-clear-all" id="clearAllBtn">æ¸…é™¤å…¨éƒ¨</button>
                </div>
                <div class="queue-list" id="queueList"></div>
            </div>

            <!-- è‡ªå‹•å„²å­˜è¨­å®š -->
            <div class="save-settings" id="saveSettings">
                <div class="save-toggle">
                    <label class="toggle-container">
                        <input type="checkbox" id="autoSaveToggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="toggle-label">è‡ªå‹•å„²å­˜åˆ°æŒ‡å®šè·¯å¾‘</span>
                </div>
                <div class="save-path-input" id="savePathInput" style="display: none;">
                    <label for="savePath">å„²å­˜è·¯å¾‘ï¼š</label>
                    <div class="input-group">
                        <input type="text" id="savePath" placeholder="/Users/ä½ çš„åç¨±/Desktop" value="">
                        <button class="btn-browse" id="browseBtn" type="button">ğŸ“‚ ç€è¦½</button>
                    </div>
                    <p class="save-hint">ğŸ’¡ è½‰éŒ„å®Œæˆå¾Œæœƒè‡ªå‹•ä»¥åŸå§‹æª”åå„²å­˜ TXT æª”æ¡ˆ</p>
                </div>
            </div>

            <!-- è½‰éŒ„æŒ‰éˆ• -->
            <button class="btn-transcribe" id="transcribeBtn" disabled>
                <span class="btn-text">é–‹å§‹è½‰éŒ„</span>
                <span class="btn-loading" style="display: none;">
                    <span class="spinner"></span>
                    è™•ç†ä¸­...
                </span>
            </button>

            <!-- é€²åº¦æç¤º -->
            <div class="progress-section" id="progressSection" style="display: none;">
                <!-- æ‰¹é‡é€²åº¦ï¼ˆé ‚éƒ¨ï¼‰ -->
                <div class="batch-progress" id="batchProgress" style="display: none;">
                    <div class="batch-header">
                        <span id="batchTitle">è™•ç†é€²åº¦</span>
                        <span id="batchCount">0/0</span>
                    </div>
                    <div class="batch-bar-container">
                        <div class="batch-bar" id="batchBar"></div>
                    </div>
                </div>

                <div class="progress-header">
                    <span class="progress-icon" id="progressIcon">ğŸ“¤</span>
                    <span class="progress-status" id="progressStatus">æº–å‚™ä¸­...</span>
                </div>

                <!-- ç•¶å‰æª”æ¡ˆåç¨±ï¼ˆæ‰¹é‡æ™‚é¡¯ç¤ºï¼‰ -->
                <div class="current-file" id="currentFile" style="display: none;">
                    æ­£åœ¨è™•ç†: <span id="currentFileName"></span>
                </div>

                <!-- ç‰‡æ®µé€²åº¦ -->
                <div class="segment-info" id="segmentInfo" style="display: none;">
                    <span id="segmentText">ç‰‡æ®µ 0/0</span>
                </div>

                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="progress-details">
                    <span class="progress-stage" id="progressStage">éšæ®µ 1/3</span>
                    <span class="progress-percent" id="progressPercent">0%</span>
                </div>
                <div class="progress-info-text" id="progressInfoText">
                    <p id="progressMessage">æ­£åœ¨ä¸Šå‚³éŸ³æª”...</p>
                    <p class="progress-hint" id="progressHint">è«‹å‹¿é—œé–‰æ­¤é é¢</p>
                </div>
                <div class="elapsed-time" id="elapsedTime">å·²ç”¨æ™‚é–“: 0:00</div>
            </div>

            <!-- çµæœå€åŸŸï¼ˆå–®æª”ï¼‰ -->
            <div class="result-section" id="resultSection" style="display: none;">
                <h2>ğŸ“ è½‰éŒ„çµæœ</h2>
                <div class="result-box">
                    <textarea id="resultText" readonly></textarea>
                </div>
                <div class="result-actions">
                    <button class="btn-copy" id="copyBtn">ğŸ“‹ è¤‡è£½æ–‡å­—</button>
                    <button class="btn-download" id="downloadBtn">â¬‡ï¸ ä¸‹è¼‰ TXT</button>
                </div>
            </div>

            <!-- çµæœå€åŸŸï¼ˆæ‰¹é‡ï¼‰ -->
            <div class="batch-result-section" id="batchResultSection" style="display: none;">
                <h2>ğŸ“ æ‰¹é‡è½‰éŒ„å®Œæˆ</h2>
                <div class="batch-result-summary">
                    <span class="result-count" id="resultCount">å·²å®Œæˆ 0 å€‹æª”æ¡ˆ</span>
                </div>
                <div class="batch-result-list" id="batchResultList"></div>
                <div class="result-actions">
                    <button class="btn-download-all" id="downloadAllBtn">â¬‡ï¸ ä¸‹è¼‰å…¨éƒ¨ (ZIP)</button>
                </div>
            </div>

            <!-- éŒ¯èª¤è¨Šæ¯ -->
            <div class="error-message" id="errorMessage" style="display: none;"></div>
        </main>

        <footer>
            <p>ä½¿ç”¨ OpenAI Whisper æŠ€è¡“ | æœ¬åœ°è™•ç†ï¼Œä¿è­·ç§éš±</p>
        </footer>
    </div>

    <script>
        // DOM å…ƒç´ 
        const singleModeBtn = document.getElementById('singleModeBtn');
        const batchModeBtn = document.getElementById('batchModeBtn');
        const uploadZone = document.getElementById('uploadZone');
        const uploadText = document.getElementById('uploadText');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const clearBtn = document.getElementById('clearBtn');
        const fileQueue = document.getElementById('fileQueue');
        const queueList = document.getElementById('queueList');
        const queueCount = document.getElementById('queueCount');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const transcribeBtn = document.getElementById('transcribeBtn');
        const progressSection = document.getElementById('progressSection');
        const batchProgress = document.getElementById('batchProgress');
        const batchTitle = document.getElementById('batchTitle');
        const batchCount = document.getElementById('batchCount');
        const batchBar = document.getElementById('batchBar');
        const currentFile = document.getElementById('currentFile');
        const currentFileName = document.getElementById('currentFileName');
        const progressIcon = document.getElementById('progressIcon');
        const progressStatus = document.getElementById('progressStatus');
        const progressBar = document.getElementById('progressBar');
        const progressStage = document.getElementById('progressStage');
        const progressPercent = document.getElementById('progressPercent');
        const progressMessage = document.getElementById('progressMessage');
        const progressHint = document.getElementById('progressHint');
        const elapsedTimeEl = document.getElementById('elapsedTime');
        const segmentInfo = document.getElementById('segmentInfo');
        const segmentText = document.getElementById('segmentText');
        const resultSection = document.getElementById('resultSection');
        const resultText = document.getElementById('resultText');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const batchResultSection = document.getElementById('batchResultSection');
        const batchResultList = document.getElementById('batchResultList');
        const resultCount = document.getElementById('resultCount');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const errorMessage = document.getElementById('errorMessage');
        const autoSaveToggle = document.getElementById('autoSaveToggle');
        const savePathInput = document.getElementById('savePathInput');
        const savePath = document.getElementById('savePath');
        const browseBtn = document.getElementById('browseBtn');

        // ç‹€æ…‹
        let mode = 'single'; // 'single' or 'batch'
        let selectedFile = null;
        let selectedFiles = [];
        let downloadId = null;
        let autoSaveEnabled = false;
        let batchId = null;
        let elapsedTimer = null;
        let startTime = null;

        // æ¨¡å¼åˆ‡æ›
        singleModeBtn.addEventListener('click', () => switchMode('single'));
        batchModeBtn.addEventListener('click', () => switchMode('batch'));

        // è‡ªå‹•å„²å­˜é–‹é—œ
        autoSaveToggle.addEventListener('change', () => {
            autoSaveEnabled = autoSaveToggle.checked;
            savePathInput.style.display = autoSaveEnabled ? 'block' : 'none';

            // å˜—è©¦å¾ localStorage è®€å–ä¸Šæ¬¡ä½¿ç”¨çš„è·¯å¾‘
            if (autoSaveEnabled && !savePath.value) {
                const lastPath = localStorage.getItem('autoSavePath');
                if (lastPath) savePath.value = lastPath;
            }
        });

        // å„²å­˜è·¯å¾‘è®Šæ›´æ™‚è¨˜ä½
        savePath.addEventListener('change', () => {
            localStorage.setItem('autoSavePath', savePath.value);
        });

        // ç€è¦½æŒ‰éˆ•é»æ“Š
        browseBtn.addEventListener('click', async () => {
            const originalText = browseBtn.textContent;
            browseBtn.textContent = 'â³ é–‹å•Ÿä¸­...';
            browseBtn.disabled = true;

            try {
                const res = await fetch('/select-folder', { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    savePath.value = data.path;
                    localStorage.setItem('autoSavePath', data.path); // æ›´æ–°è¨˜æ†¶
                } else if (data.message === 'User cancelled') {
                    // ç”¨æˆ¶å–æ¶ˆï¼Œä¸åšä»»ä½•äº‹
                } else {
                    showError('é¸æ“‡è·¯å¾‘å¤±æ•—: ' + (data.error || 'æœªçŸ¥éŒ¯èª¤'));
                }
            } catch (err) {
                showError('ç„¡æ³•é–‹å•Ÿè³‡æ–™å¤¾é¸æ“‡å™¨: ' + err.message);
            } finally {
                browseBtn.textContent = originalText;
                browseBtn.disabled = false;
            }
        });

        function switchMode(newMode) {
            mode = newMode;

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            singleModeBtn.classList.toggle('active', mode === 'single');
            batchModeBtn.classList.toggle('active', mode === 'batch');

            // æ›´æ–° file input
            fileInput.multiple = (mode === 'batch');

            // æ›´æ–°æç¤ºæ–‡å­—
            uploadText.textContent = mode === 'batch'
                ? 'æ‹–æ‹½å¤šå€‹éŸ³æª”åˆ°é€™è£¡ï¼Œæˆ–é»æ“Šé¸æ“‡'
                : 'æ‹–æ‹½éŸ³æª”åˆ°é€™è£¡ï¼Œæˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ';

            // æ¸…é™¤ç‹€æ…‹
            resetAll();
        }

        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // æ ¼å¼åŒ–æª”æ¡ˆå¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // æ ¼å¼åŒ–æ™‚é•·
        function formatDuration(seconds) {
            if (seconds < 60) return `${Math.round(seconds)} ç§’`;
            return `${Math.round(seconds / 60)} åˆ†é˜`;
        }

        // é–‹å§‹è¨ˆæ™‚
        function startElapsedTimer() {
            startTime = Date.now();
            elapsedTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                elapsedTimeEl.textContent = `å·²ç”¨æ™‚é–“: ${formatTime(elapsed)}`;
            }, 1000);
        }

        // åœæ­¢è¨ˆæ™‚
        function stopElapsedTimer() {
            if (elapsedTimer) {
                clearInterval(elapsedTimer);
                elapsedTimer = null;
            }
        }

        // æ›´æ–°é€²åº¦é¡¯ç¤º
        function updateProgress(percent, icon, status, message, hint, stage = null) {
            progressIcon.textContent = icon;
            progressStatus.textContent = status;
            progressBar.style.width = percent + '%';
            progressPercent.textContent = percent + '%';
            progressMessage.textContent = message;
            if (hint) progressHint.textContent = hint;
            if (stage) progressStage.textContent = stage;
        }

        // é¡¯ç¤ºç‰‡æ®µé€²åº¦
        function showSegmentProgress(current, total) {
            segmentInfo.style.display = 'block';
            segmentText.textContent = `ç‰‡æ®µ ${current}/${total}`;
        }

        // é»æ“Šä¸Šå‚³å€åŸŸ
        uploadZone.addEventListener('click', () => fileInput.click());

        // æ‹–æ‹½äº‹ä»¶
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            if (mode === 'single' && files.length > 0) {
                handleSingleFile(files[0]);
            } else if (mode === 'batch') {
                handleBatchFiles(files);
            }
        });

        // æª”æ¡ˆé¸æ“‡
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (mode === 'single' && files.length > 0) {
                handleSingleFile(files[0]);
            } else if (mode === 'batch') {
                handleBatchFiles(files);
            }
        });

        // è™•ç†å–®æª”é¸æ“‡
        function handleSingleFile(file) {
            selectedFile = file;
            fileName.textContent = `${file.name} (${formatFileSize(file.size)})`;
            fileInfo.style.display = 'flex';
            uploadZone.style.display = 'none';
            transcribeBtn.disabled = false;
            hideError();
            hideResult();
        }

        // è™•ç†æ‰¹é‡é¸æ“‡
        function handleBatchFiles(files) {
            // éæ¿¾æœ‰æ•ˆæª”æ¡ˆ
            const validFiles = files.filter(f => {
                const ext = f.name.split('.').pop().toLowerCase();
                return ['mp3', 'wav', 'mp4', 'm4a', 'ogg', 'flac', 'webm'].includes(ext);
            });

            if (validFiles.length === 0) {
                showError('æ²’æœ‰æœ‰æ•ˆçš„éŸ³æª”');
                return;
            }

            if (selectedFiles.length + validFiles.length > 10) {
                showError('æœ€å¤šåªèƒ½ä¸Šå‚³ 10 å€‹æª”æ¡ˆ');
                return;
            }

            selectedFiles = [...selectedFiles, ...validFiles];
            renderFileQueue();
            uploadZone.style.display = 'none';
            fileQueue.style.display = 'block';
            transcribeBtn.disabled = false;
            hideError();
            hideResult();
        }

        // æ¸²æŸ“æª”æ¡ˆéšŠåˆ—
        function renderFileQueue() {
            queueList.innerHTML = '';
            queueCount.textContent = `(${selectedFiles.length} å€‹æª”æ¡ˆ)`;

            selectedFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'queue-item';
                item.innerHTML = `
                    <div class="queue-item-info">
                        <span class="queue-item-name">${file.name}</span>
                        <span class="queue-item-size">${formatFileSize(file.size)}</span>
                    </div>
                    <button class="queue-item-remove" data-index="${index}">âœ•</button>
                `;
                queueList.appendChild(item);
            });

            // ç§»é™¤å–®å€‹æª”æ¡ˆ
            queueList.querySelectorAll('.queue-item-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    selectedFiles.splice(index, 1);
                    if (selectedFiles.length === 0) {
                        resetBatchUpload();
                    } else {
                        renderFileQueue();
                    }
                });
            });
        }

        // æ¸…é™¤å–®æª”
        clearBtn.addEventListener('click', () => resetSingleUpload());

        // æ¸…é™¤å…¨éƒ¨
        clearAllBtn.addEventListener('click', () => resetBatchUpload());

        function resetSingleUpload() {
            selectedFile = null;
            fileInput.value = '';
            fileInfo.style.display = 'none';
            uploadZone.style.display = 'flex';
            transcribeBtn.disabled = true;
            segmentInfo.style.display = 'none';
        }

        function resetBatchUpload() {
            selectedFiles = [];
            fileInput.value = '';
            fileQueue.style.display = 'none';
            uploadZone.style.display = 'flex';
            transcribeBtn.disabled = true;
        }

        function resetAll() {
            resetSingleUpload();
            resetBatchUpload();
            hideResult();
            hideError();
            progressSection.style.display = 'none';
        }

        // é–‹å§‹è½‰éŒ„
        transcribeBtn.addEventListener('click', async () => {
            if (mode === 'single') {
                await startSingleTranscription();
            } else {
                await startBatchTranscription();
            }
        });

        // å–®æª”è½‰éŒ„
        async function startSingleTranscription() {
            if (!selectedFile) return;

            const btnText = transcribeBtn.querySelector('.btn-text');
            const btnLoading = transcribeBtn.querySelector('.btn-loading');

            btnText.style.display = 'none';
            btnLoading.style.display = 'inline-flex';
            transcribeBtn.disabled = true;
            progressSection.style.display = 'block';
            batchProgress.style.display = 'none';
            currentFile.style.display = 'none';
            segmentInfo.style.display = 'none';
            hideError();
            hideResult();

            startElapsedTimer();
            updateProgress(0, 'ğŸ“¤', 'ä¸Šå‚³ä¸­', `æ­£åœ¨ä¸Šå‚³ ${selectedFile.name}...`, 'è«‹å‹¿é—œé–‰æ­¤é é¢', 'éšæ®µ 1/3 - ä¸Šå‚³');

            try {
                const formData = new FormData();
                formData.append('audio', selectedFile);

                const uploadResponse = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const uploadData = await uploadResponse.json();

                if (!uploadData.success) {
                    throw new Error(uploadData.error || 'ä¸Šå‚³å¤±æ•—');
                }

                const fileId = uploadData.file_id;
                downloadId = fileId;

                updateProgress(10, 'ğŸ“¤', 'ä¸Šå‚³å®Œæˆ', 'æª”æ¡ˆå·²ä¸Šå‚³ï¼Œæº–å‚™é–‹å§‹è½‰éŒ„...',
                    uploadData.segment_count > 1 ? `å°‡åˆ†æˆ ${uploadData.segment_count} å€‹ç‰‡æ®µè™•ç†` : 'å–®ä¸€ç‰‡æ®µè™•ç†',
                    'éšæ®µ 2/3 - è™•ç†');

                const eventSource = new EventSource(`/transcribe/${fileId}`);

                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.error) {
                        eventSource.close();
                        showError(data.error);
                        resetUI();
                        return;
                    }

                    const progress = data.progress || 0;

                    if (data.stage === 'splitting') {
                        updateProgress(progress, 'âœ‚ï¸', 'åˆ†å‰²ä¸­', data.message, 'æ­£åœ¨åˆ†å‰²é•·éŒ„éŸ³...', 'éšæ®µ 2/3 - åˆ†å‰²');
                    } else if (data.stage === 'transcribing') {
                        const currentSeg = data.current_segment || 0;
                        const totalSeg = data.total_segments || 1;
                        showSegmentProgress(currentSeg, totalSeg);
                        updateProgress(progress, 'ğŸ™ï¸', 'è½‰éŒ„ä¸­', data.message,
                            `ç¬¬ ${currentSeg}/${totalSeg} å€‹ç‰‡æ®µ`,
                            `éšæ®µ 2/3 - è½‰éŒ„ (${currentSeg}/${totalSeg})`);
                    } else if (data.stage === 'finalizing') {
                        updateProgress(progress, 'ğŸ“', 'è™•ç†ä¸­', data.message, 'å³å°‡å®Œæˆ...', 'éšæ®µ 3/3 - å®Œæˆ');
                    } else if (data.stage === 'complete') {
                        eventSource.close();
                        updateProgress(100, 'âœ…', 'å®Œæˆï¼', 'è½‰éŒ„æˆåŠŸï¼', 'å¯ä»¥æŸ¥çœ‹å’Œä¸‹è¼‰çµæœ', 'å®Œæˆ');

                        setTimeout(async () => {
                            resultText.value = data.transcript;
                            downloadId = data.download_id;
                            resultSection.style.display = 'block';
                            progressSection.style.display = 'none';
                            resetUI();

                            // è‡ªå‹•å„²å­˜
                            if (autoSaveEnabled && savePath.value) {
                                try {
                                    const saveRes = await fetch('/auto-save', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            save_path: savePath.value,
                                            file_id: downloadId,
                                            original_name: selectedFile.name,
                                            transcript: data.transcript
                                        })
                                    });
                                    const saveData = await saveRes.json();
                                    if (saveData.success) {
                                        showAutoSaveSuccess(saveData.saved_path);
                                    } else {
                                        showError('è‡ªå‹•å„²å­˜å¤±æ•—: ' + saveData.error);
                                    }
                                } catch (e) {
                                    showError('è‡ªå‹•å„²å­˜å¤±æ•—: ' + e.message);
                                }
                            }
                        }, 500);
                    }
                };

                eventSource.onerror = () => {
                    eventSource.close();
                    showError('é€£ç·šä¸­æ–·ï¼Œè«‹é‡è©¦');
                    resetUI();
                };

            } catch (error) {
                showError(error.message || 'è™•ç†å¤±æ•—');
                resetUI();
            }
        }

        // æ‰¹é‡è½‰éŒ„
        async function startBatchTranscription() {
            if (selectedFiles.length === 0) return;

            const btnText = transcribeBtn.querySelector('.btn-text');
            const btnLoading = transcribeBtn.querySelector('.btn-loading');

            btnText.style.display = 'none';
            btnLoading.style.display = 'inline-flex';
            transcribeBtn.disabled = true;
            progressSection.style.display = 'block';
            batchProgress.style.display = 'block';
            currentFile.style.display = 'block';
            segmentInfo.style.display = 'none';
            hideError();
            hideResult();

            startElapsedTimer();
            updateProgress(0, 'ğŸ“¤', 'ä¸Šå‚³ä¸­', 'æ­£åœ¨ä¸Šå‚³æª”æ¡ˆ...', 'è«‹å‹¿é—œé–‰æ­¤é é¢', 'éšæ®µ 1/3 - ä¸Šå‚³');
            batchCount.textContent = `0/${selectedFiles.length}`;
            batchBar.style.width = '0%';

            try {
                const formData = new FormData();
                selectedFiles.forEach(file => {
                    formData.append('audio', file);
                });

                const uploadResponse = await fetch('/upload-batch', {
                    method: 'POST',
                    body: formData
                });

                const uploadData = await uploadResponse.json();

                if (!uploadData.success) {
                    throw new Error(uploadData.error || 'ä¸Šå‚³å¤±æ•—');
                }

                batchId = uploadData.batch_id;
                const totalFiles = uploadData.total;
                const fileResults = [];

                updateProgress(10, 'ğŸ“¤', 'ä¸Šå‚³å®Œæˆ', `å·²ä¸Šå‚³ ${totalFiles} å€‹æª”æ¡ˆ`, 'æº–å‚™é–‹å§‹è½‰éŒ„...', 'éšæ®µ 2/3 - è™•ç†');

                const eventSource = new EventSource(`/transcribe-batch/${batchId}`);

                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.error) {
                        eventSource.close();
                        showError(data.error);
                        resetUI();
                        return;
                    }

                    // æ›´æ–°æ‰¹é‡é€²åº¦
                    if (data.batch_progress !== undefined) {
                        batchBar.style.width = data.batch_progress + '%';
                    }

                    if (data.stage === 'file_start') {
                        currentFileName.textContent = data.file_name;
                        batchCount.textContent = `${data.file_index + 1}/${data.total_files}`;
                    } else if (data.stage === 'splitting') {
                        updateProgress(data.progress, 'âœ‚ï¸', 'åˆ†å‰²ä¸­', data.message, '', 'åˆ†å‰²');
                    } else if (data.stage === 'transcribing') {
                        const currentSeg = data.current_segment || 0;
                        const totalSeg = data.total_segments || 1;
                        if (totalSeg > 1) {
                            showSegmentProgress(currentSeg, totalSeg);
                        }
                        updateProgress(data.progress, 'ğŸ™ï¸', 'è½‰éŒ„ä¸­', data.message, '', 'è½‰éŒ„');
                    } else if (data.stage === 'finalizing') {
                        updateProgress(data.progress, 'ğŸ“', 'è™•ç†ä¸­', data.message, '', 'å®Œæˆ');
                    } else if (data.stage === 'complete') {
                        // å–®å€‹æª”æ¡ˆå®Œæˆï¼Œè¨˜éŒ„çµæœ
                        fileResults.push({
                            name: data.file_name,
                            transcript: data.transcript,
                            download_id: data.download_id
                        });
                    } else if (data.stage === 'file_complete') {
                        batchCount.textContent = `${data.completed}/${data.total_files}`;
                        batchBar.style.width = ((data.completed / data.total_files) * 100) + '%';
                    } else if (data.stage === 'batch_complete') {
                        eventSource.close();
                        updateProgress(100, 'âœ…', 'å…¨éƒ¨å®Œæˆï¼', data.message, '', 'å®Œæˆ');

                        setTimeout(async () => {
                            showBatchResults(fileResults);
                            progressSection.style.display = 'none';
                            resetUI();

                            // æ‰¹é‡è‡ªå‹•å„²å­˜
                            if (autoSaveEnabled && savePath.value) {
                                try {
                                    const saveRes = await fetch('/auto-save-batch', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            save_path: savePath.value,
                                            files: fileResults
                                        })
                                    });
                                    const saveData = await saveRes.json();
                                    if (saveData.success) {
                                        const msg = `å·²è‡ªå‹•å„²å­˜ ${saveData.saved_count} å€‹æª”æ¡ˆ`;
                                        if (saveData.errors.length > 0) {
                                            showError(msg + `ï¼Œä½†æœ‰ ${saveData.errors.length} å€‹å¤±æ•—`);
                                        } else {
                                            showAutoSaveSuccess(savePath.value);
                                        }
                                    } else {
                                        showError('è‡ªå‹•å„²å­˜å¤±æ•—: ' + saveData.error);
                                    }
                                } catch (e) {
                                    showError('è‡ªå‹•å„²å­˜å¤±æ•—: ' + e.message);
                                }
                            }
                        }, 500);
                    }
                };

                eventSource.onerror = () => {
                    eventSource.close();
                    showError('é€£ç·šä¸­æ–·ï¼Œè«‹é‡è©¦');
                    resetUI();
                };

            } catch (error) {
                showError(error.message || 'è™•ç†å¤±æ•—');
                resetUI();
            }
        }

        // é¡¯ç¤ºæ‰¹é‡çµæœ
        function showBatchResults(results) {
            batchResultSection.style.display = 'block';
            resultCount.textContent = `å·²å®Œæˆ ${results.length} å€‹æª”æ¡ˆ`;
            batchResultList.innerHTML = '';

            results.forEach((result, index) => {
                const item = document.createElement('div');
                item.className = 'batch-result-item';
                item.innerHTML = `
                    <div class="result-item-header">
                        <span class="result-item-name">ğŸ“„ ${result.name}</span>
                        <button class="btn-expand" data-index="${index}">å±•é–‹</button>
                    </div>
                    <div class="result-item-content" id="resultContent${index}" style="display: none;">
                        <textarea readonly>${result.transcript}</textarea>
                        <div class="result-item-actions">
                            <button class="btn-copy-item" data-index="${index}">ğŸ“‹ è¤‡è£½</button>
                        </div>
                    </div>
                `;
                batchResultList.appendChild(item);
            });

            // å±•é–‹/æ”¶èµ·
            batchResultList.querySelectorAll('.btn-expand').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = e.target.dataset.index;
                    const content = document.getElementById(`resultContent${index}`);
                    const isVisible = content.style.display !== 'none';
                    content.style.display = isVisible ? 'none' : 'block';
                    e.target.textContent = isVisible ? 'å±•é–‹' : 'æ”¶èµ·';
                });
            });

            // è¤‡è£½å–®å€‹çµæœ
            batchResultList.querySelectorAll('.btn-copy-item').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    await navigator.clipboard.writeText(results[index].transcript);
                    e.target.textContent = 'âœ… å·²è¤‡è£½';
                    setTimeout(() => { e.target.textContent = 'ğŸ“‹ è¤‡è£½'; }, 2000);
                });
            });
        }

        function resetUI() {
            stopElapsedTimer();
            const btnText = transcribeBtn.querySelector('.btn-text');
            const btnLoading = transcribeBtn.querySelector('.btn-loading');
            btnText.style.display = 'inline';
            btnLoading.style.display = 'none';
            transcribeBtn.disabled = false;
        }

        // è¤‡è£½æ–‡å­—
        copyBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(resultText.value);
                copyBtn.textContent = 'âœ… å·²è¤‡è£½';
                setTimeout(() => { copyBtn.textContent = 'ğŸ“‹ è¤‡è£½æ–‡å­—'; }, 2000);
            } catch (error) {
                showError('è¤‡è£½å¤±æ•—');
            }
        });

        // ä¸‹è¼‰å–®å€‹ TXT
        downloadBtn.addEventListener('click', async () => {
            const content = resultText.value;
            if (!content) return;

            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'è½‰éŒ„çµæœ.txt',
                        types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(content);
                    await writable.close();

                    downloadBtn.textContent = 'âœ… å·²å„²å­˜';
                    setTimeout(() => { downloadBtn.textContent = 'â¬‡ï¸ ä¸‹è¼‰ TXT'; }, 2000);
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') return;
                }
            }

            const filename = prompt('è«‹è¼¸å…¥æª”æ¡ˆåç¨±ï¼š', 'è½‰éŒ„çµæœ') || 'è½‰éŒ„çµæœ';
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // ä¸‹è¼‰å…¨éƒ¨ ZIP
        downloadAllBtn.addEventListener('click', () => {
            if (!batchId) return;
            window.location.href = `/download-batch/${batchId}`;
        });

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            progressSection.style.display = 'none';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 5000);
        }

        function showAutoSaveSuccess(path) {
            const successMsg = document.createElement('div');
            successMsg.className = 'auto-save-success';
            successMsg.innerHTML = `âœ… å·²è‡ªå‹•å„²å­˜è‡³ï¼š<br>${path}`;
            document.body.appendChild(successMsg);

            // CSS for toast
            const style = document.createElement('style');
            style.textContent = `
                .auto-save-success {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: var(--bg-card);
                    color: var(--text-primary);
                    padding: 1rem 1.5rem;
                    border-radius: 12px;
                    border: 1px solid var(--success);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    z-index: 1000;
                    animation: slideIn 0.3s ease;
                    font-size: 0.9rem;
                    line-height: 1.5;
                }
                .auto-save-success.fade-out {
                    animation: fadeOut 0.5s ease forwards;
                }
                @keyframes slideIn {
                    from { transform: translateY(100%); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes fadeOut {
                    to { opacity: 0; transform: translateY(20px); }
                }
            `;
            document.head.appendChild(style);

            setTimeout(() => {
                successMsg.classList.add('fade-out');
                setTimeout(() => successMsg.remove(), 500);
            }, 3000);
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        function hideResult() {
            resultSection.style.display = 'none';
            batchResultSection.style.display = 'none';
        }
    </script>
</body>

</html>